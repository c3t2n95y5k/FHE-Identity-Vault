import { ethers as EthersT } from "ethers";
import { BlockLogCursor } from "../../ethers/event.js";
import type { MinimalProvider } from "../../ethers/provider.js";
import type { DecryptionOracleEvent, DecryptionRequestEvent } from "./DecryptionOracleEvents.js";
export declare function getDecryptionOracleEvents(decryptionOracleContractInterface: EthersT.Interface, decryptionOracleContractAddress: string, readonlyProvider: EthersT.Provider, options: {
    fromBlockNumber?: number;
    fromBlockLogIndex?: number;
    toBlockNumber?: number;
}): Promise<{
    events: DecryptionOracleEvent[];
    cursor: BlockLogCursor;
}>;
export declare function toDecryptionRequestEvent(e: DecryptionOracleEvent): DecryptionRequestEvent | null;
export declare function parseDecryptionRequestEventsFromLogs(logs: (EthersT.EventLog | EthersT.Log)[] | null | undefined): DecryptionRequestEvent[];
/**
 * Retrieves the `DecryptionOracleAddress` from a smart contract that utilizes the FHEVM framework,
 * deployed at the given `contractAddress`.
 *
 * This function computes the storage slot corresponding to the `DecryptionRequestsStruct` defined in
 * [`@fhevm/solidity/lib/Impl.sol`](https://github.com/zama-ai/fhevm-solidity/blob/main/lib/Impl.sol),
 * then reads the first address field (the oracle address) directly from storage.
 *
 * @param provider - A `MinimalProvider` that implements either `send` or `request` for JSON-RPC communication.
 * @param contractAddress - The on-chain address of the FHEVM contract to query.
 * @returns A Promise that resolves to the decryption oracle's Ethereum address.
 *
 * @throws If the computed storage slot does not match the expected constant layout, indicating a version or layout mismatch.
 */
export declare function getDecryptionOracleAddress(provider: MinimalProvider, contractAddress: string): Promise<string>;
//# sourceMappingURL=utils.d.ts.map